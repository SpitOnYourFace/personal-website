---
---

<section id="hero" class="relative min-h-screen flex items-center overflow-hidden" style="background:linear-gradient(to bottom, #0c0c1d 0%, #0c0c1d 55%, #0e1028 65%, #111535 75%, #1a2555 85%, #2a3a78 100%)">
  <!-- Accessible autobiography text (sr-only) -->
  <div class="sr-only" role="region" aria-label="About Krasimir Kralev">
    <p data-lang="en">My name is Krasimir Kralev. I'm a QA specialist at ResultsCX, studying Computer Science at Plovdiv University. I play guitar in Slathe and build web applications with JavaScript, Node.js, Astro and Tailwind CSS. I'm passionate about Web3 and the Internet Computer Protocol.</p>
    <p data-lang="bg">Казвам се Красимир Кралев. Специалист по качеството в ResultsCX, уча Информатика в Пловдивски университет. Свиря на китара в Slathe и изграждам уеб приложения с JavaScript, Node.js, Astro и Tailwind CSS. Увлечен съм от Web3 и Internet Computer Protocol.</p>
  </div>

  <!-- Starfield -->
  <div class="starfield absolute inset-0 z-[3] pointer-events-none" aria-hidden="true">
    <!-- Small stars -->
    <div class="star s-sm" style="top:5%;left:8%"></div>
    <div class="star s-sm" style="top:12%;left:22%"></div>
    <div class="star s-sm" style="top:3%;left:45%"></div>
    <div class="star s-sm" style="top:18%;left:62%"></div>
    <div class="star s-sm" style="top:8%;left:78%"></div>
    <div class="star s-sm" style="top:15%;left:91%"></div>
    <div class="star s-sm" style="top:25%;left:15%"></div>
    <div class="star s-sm" style="top:30%;left:55%"></div>
    <div class="star s-sm" style="top:22%;left:85%"></div>
    <div class="star s-sm" style="top:35%;left:35%"></div>
    <div class="star s-sm" style="top:42%;left:72%"></div>
    <div class="star s-sm" style="top:38%;left:5%"></div>
    <div class="star s-sm" style="top:48%;left:92%"></div>
    <div class="star s-sm" style="top:55%;left:18%"></div>
    <div class="star s-sm" style="top:52%;left:48%"></div>
    <div class="star s-sm" style="top:62%;left:82%"></div>
    <div class="star s-sm" style="top:68%;left:30%"></div>
    <div class="star s-sm" style="top:58%;left:65%"></div>
    <div class="star s-sm" style="top:72%;left:10%"></div>
    <div class="star s-sm" style="top:78%;left:58%"></div>
    <!-- Medium stars -->
    <div class="star s-md" style="top:7%;left:32%"></div>
    <div class="star s-md" style="top:16%;left:72%"></div>
    <div class="star s-md" style="top:28%;left:48%"></div>
    <div class="star s-md" style="top:20%;left:4%"></div>
    <div class="star s-md" style="top:40%;left:88%"></div>
    <div class="star s-md" style="top:45%;left:25%"></div>
    <div class="star s-md" style="top:55%;left:78%"></div>
    <div class="star s-md" style="top:65%;left:42%"></div>
    <div class="star s-md" style="top:75%;left:90%"></div>
    <div class="star s-md" style="top:70%;left:55%"></div>
    <!-- Bright stars with glow -->
    <div class="star s-lg" style="top:10%;left:52%"></div>
    <div class="star s-lg" style="top:32%;left:18%"></div>
    <div class="star s-lg" style="top:24%;left:92%"></div>
    <div class="star s-lg" style="top:50%;left:40%"></div>
    <div class="star s-lg" style="top:60%;left:95%"></div>
    <div class="star s-lg" style="top:73%;left:70%"></div>
  </div>

  <!-- Autobiography text layer (revealed by spotlight) -->
  <div class="code-layer absolute inset-0 select-none pointer-events-none z-0" aria-hidden="true">
    <pre class="code-block code-block-1" data-lang="en">{`My name is Krasimir Kralev.
Curiosity drives everything I do.
I love solving problems and
helping people along the way.

I study Computer Science, but
it doesn't stop at university —
I code in my free time because
it burns inside me. A true calling.`}</pre>
    <pre class="code-block code-block-1" data-lang="bg">{`Казвам се Красимир Кралев.
Любопитството движи всичко,
което правя. Обичам да решавам
проблеми и да помагам на хората.

Уча Информатика, но не спира
до университета — програмирам
в свободното си време, защото
гори в мен. Истинско призвание.`}</pre>

    <pre class="code-block code-block-2" data-lang="en">{`At ResultsCX I'm a Quality Assurance
& Development Specialist on the
Sky UK project.

I'm not a programmer at work —
I ensure data security, prevent
breaches, and help my team grow.
Quality and people come first.`}</pre>
    <pre class="code-block code-block-2" data-lang="bg">{`В ResultsCX съм специалист по
Качество и развитие по проекта
Sky UK.

На работа не програмирам —
осигурявам сигурност на данните,
предотвратявам пробиви и помагам
на екипа ми да расте.`}</pre>

    <pre class="code-block code-block-3" data-lang="en">{`I study Informatics at the
University of Plovdiv
"Paisii Hilendarski" — one of
the oldest universities in Bulgaria.

Every lecture fuels my curiosity.
Every algorithm sharpens my mind.
The classroom opened the door,
but passion keeps me walking.`}</pre>
    <pre class="code-block code-block-3" data-lang="bg">{`Уча Информатика в Пловдивски
университет „Паисий Хилендарски"
— един от най-старите
университети в България.

Всяка лекция подхранва
любопитството ми. Всеки алгоритъм
ми изостря ума. Университетът
отвори вратата, но страстта
ме движи напред.`}</pre>

    <pre class="code-block code-block-4" data-lang="en">{`But code isn't my only language.
I play guitar in Slathe — a band
born from the same fire that
drives my programming.

Music and code share a rhythm.
Both demand precision, creativity,
and the courage to break rules.`}</pre>
    <pre class="code-block code-block-4" data-lang="bg">{`Но кодът не е единственият
ми език. Свиря на китара в
Slathe — група, родена от
същия огън, който движи
програмирането ми.

Музиката и кодът споделят
ритъм. И двете изискват
прецизност и креативност.`}</pre>

    <pre class="code-block code-block-5" data-lang="en">{`JavaScript is my weapon of choice.
Node.js, Astro, Tailwind CSS —
I build things that live and
breathe on the internet.`}</pre>
    <pre class="code-block code-block-5" data-lang="bg">{`JavaScript е моето оръжие.
Node.js, Astro, Tailwind CSS —
изграждам неща, които живеят
и дишат в интернет.`}</pre>

    <pre class="code-block code-block-6" data-lang="en">{`The future excites me.
Web3 and the Internet Computer
Protocol (ICP) are calling.

I want to build decentralized
apps that change how we think
about the web.

This is just the beginning.`}</pre>
    <pre class="code-block code-block-6" data-lang="bg">{`Бъдещето ме вълнува.
Web3 и Internet Computer
Protocol (ICP) ме зоват.

Искам да създавам децентрализирани
приложения, които да променят
мисленето ни за мрежата.

Това е само началото.`}</pre>
  </div>

  <!-- Spotlight overlay (mask-based: supports cursor + star spotlights simultaneously) -->
  <div id="spotlight-overlay" class="absolute inset-0 z-[1] pointer-events-none"></div>

  <!-- Particle canvas (GPU-composited) -->
  <canvas id="particles" class="absolute inset-0 w-full h-full z-[2]" role="img" aria-label="Animated particle network background" style="will-change:transform"></canvas>

  <!-- Content -->
  <div id="main-content" class="relative z-10 max-w-2xl mx-auto px-6 pt-20">
    <p
      id="hero-subtitle"
      class="font-mono text-xs uppercase tracking-[3px] text-[#c8973e]/60 mb-4 opacity-0 translate-y-2 transition-all duration-700"
    >
      <span id="hero-role"></span>
    </p>
    <h1 class="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-bold text-white leading-tight mb-5 min-h-[1.3em] font-mono">
      <span id="typed-text"></span><span id="typed-cursor" class="text-[#c8973e] animate-blink inline-block w-0 overflow-visible">|</span>
    </h1>
    <p class="text-lg text-white/50 mb-10 max-w-md">
      <span data-lang="en">I write code that speaks for itself.</span>
      <span data-lang="bg">Пиша код, който говори сам за себе си.</span>
    </p>
    <div id="hero-cta" class="flex flex-wrap items-center gap-4 opacity-0 translate-y-2 transition-all duration-700 delay-300">
      <a
        href="#about"
        class="inline-flex items-center gap-2 text-[#c8973e] font-medium text-sm hover:underline underline-offset-4 decoration-[#c8973e]/40"
      >
        <span data-lang="en">View my work</span>
        <span data-lang="bg">Вижте работата ми</span>
        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 14l-7 7m0 0l-7-7m7 7V3" />
        </svg>
      </a>
      <button
        id="story-guide-btn"
        class="story-btn group relative inline-flex cursor-pointer font-mono text-xs uppercase tracking-wider rounded-full px-5 py-2 md:px-5 md:py-2 border border-[#c8973e]/30 text-[#c8973e]/70 hover:text-[#c8973e] hover:border-[#c8973e]/60 transition-all duration-300 focus-visible:outline focus-visible:outline-2 focus-visible:outline-[#c8973e] outline-offset-2 max-md:w-9 max-md:h-9 max-md:p-0 max-md:items-center max-md:justify-center max-md:border-[#c8973e]/20"
        aria-label="Read my story"
      >
        <span class="relative z-10 flex items-center gap-2">
          <svg class="w-3.5 h-3.5 transition-transform duration-300 group-hover:rotate-[20deg]" fill="currentColor" viewBox="0 0 24 24">
            <path d="M12 2l2.09 6.26L20.18 9l-5 4.27L16.82 20 12 16.77 7.18 20l1.64-6.73L3.82 9l6.09-.74z"/>
          </svg>
          <span class="hidden md:inline" data-lang="en">Read my story</span>
          <span class="hidden md:inline" data-lang="bg">Прочетете историята ми</span>
        </span>
      </button>
    </div>
  </div>

  <!-- Hint: desktop (hidden by default, shown by star trail) -->
  <div id="hero-hint" class="absolute inset-0 z-[3] pointer-events-none hidden"></div>


  <!-- Star trail guide SVG -->
  <svg id="star-trail" class="absolute inset-0 w-full h-full z-[11] pointer-events-none" style="display:none" aria-hidden="true">
    <defs>
      <filter id="star-glow">
        <feGaussianBlur stdDeviation="3" result="blur"/>
        <feMerge>
          <feMergeNode in="blur"/>
          <feMergeNode in="SourceGraphic"/>
        </feMerge>
      </filter>
      <radialGradient id="star-grad">
        <stop offset="0%" stop-color="#ffd97a"/>
        <stop offset="50%" stop-color="#c8973e"/>
        <stop offset="100%" stop-color="#c8973e" stop-opacity="0"/>
      </radialGradient>
    </defs>
    <path id="trail-path" fill="none" stroke="url(#star-grad)" stroke-width="2" stroke-linecap="round" filter="url(#star-glow)" opacity="0"/>
    <circle id="trail-star" r="5" fill="#ffd97a" filter="url(#star-glow)" opacity="0"/>
    <!-- Sparkle particles -->
    <g id="trail-sparkles"></g>
  </svg>
</section>

<style>
  /* ===== STARFIELD ===== */
  .starfield {
    contain: strict;
    mask-image: linear-gradient(to bottom, white 0%, white 60%, transparent 90%);
    -webkit-mask-image: linear-gradient(to bottom, white 0%, white 60%, transparent 90%);
  }

  .star {
    position: absolute;
    border-radius: 50%;
    background: rgba(200, 215, 255, 0.9);
    will-change: opacity;
  }

  /* Static glow via sized element + blur — painted once, never re-painted */
  .s-sm {
    width: 3px;
    height: 3px;
    filter: blur(1px);
    opacity: 0.15;
    animation: twinkle-sm 3s ease-in-out infinite;
  }

  .s-md {
    width: 5px;
    height: 5px;
    filter: blur(1.5px);
    opacity: 0.2;
    animation: twinkle-md 2.5s ease-in-out infinite;
  }

  .s-lg {
    width: 7px;
    height: 7px;
    filter: blur(2px);
    opacity: 0.3;
    will-change: opacity, transform;
    animation: twinkle-lg 4s ease-in-out infinite;
  }

  /* Stagger animations so stars don't all blink together */
  .star:nth-child(2n)   { animation-delay: -0.8s; }
  .star:nth-child(3n)   { animation-delay: -1.7s; }
  .star:nth-child(5n)   { animation-delay: -0.4s; }
  .star:nth-child(7n)   { animation-delay: -2.3s; }
  .star:nth-child(11n)  { animation-delay: -1.1s; }
  .star:nth-child(13n)  { animation-delay: -3.0s; }

  /* GPU-composited: only opacity (and transform for large) — no box-shadow repaints */
  @keyframes twinkle-sm {
    0%, 100% { opacity: 0.1; }
    50% { opacity: 0.9; }
  }

  @keyframes twinkle-md {
    0%, 100% { opacity: 0.15; }
    50% { opacity: 1; }
  }

  @keyframes twinkle-lg {
    0%, 100% { opacity: 0.2; transform: scale(1); }
    50% { opacity: 1; transform: scale(1.5); }
  }

  .code-layer { overflow: hidden; }
  .code-block {
    position: absolute;
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    line-height: 1.75;
    color: rgb(255, 215, 110);
    text-shadow: 0 0 8px rgba(255, 200, 80, 0.3);
    white-space: pre;
    letter-spacing: 0.3px;
    max-width: 24vw;
  }

  /* Left column — evenly spaced, 24% gaps */
  .code-block-1 { top: 8%;  left: 3%; }
  .code-block-3 { top: 12%; left: 50%; transform: translateX(-50%); }
  .code-block-5 { top: 58%; left: 3%; }

  /* Right column — offset from left, 24% gaps */
  .code-block-2 { top: 10%; right: 3%; }
  .code-block-4 { top: calc(36% - 8px); right: 2%; }
  .code-block-6 { top: 60%; right: 3%; }

  #spotlight-overlay {
    background: rgba(12, 12, 29, 1);
    -webkit-mask-image:
      radial-gradient(circle 420px at var(--mx, -200%) var(--my, -200%),
        transparent 0%, rgba(0,0,0,0.2) 25%, rgba(0,0,0,0.7) 50%, rgba(0,0,0,0.95) 70%, black 85%),
      radial-gradient(circle 420px at var(--sx, -200%) var(--sy, -200%),
        transparent 0%, rgba(0,0,0,0.2) 25%, rgba(0,0,0,0.7) 50%, rgba(0,0,0,0.95) 70%, black 85%);
    mask-image:
      radial-gradient(circle 420px at var(--mx, -200%) var(--my, -200%),
        transparent 0%, rgba(0,0,0,0.2) 25%, rgba(0,0,0,0.7) 50%, rgba(0,0,0,0.95) 70%, black 85%),
      radial-gradient(circle 420px at var(--sx, -200%) var(--sy, -200%),
        transparent 0%, rgba(0,0,0,0.2) 25%, rgba(0,0,0,0.7) 50%, rgba(0,0,0,0.95) 70%, black 85%);
    -webkit-mask-composite: source-in;
    mask-composite: intersect;
  }

  .story-btn {
    position: relative;
    -webkit-tap-highlight-color: transparent;
  }
  /* GPU-composited glow: static shadow on pseudo, animate only opacity */
  .story-btn::before {
    content: '';
    position: absolute;
    inset: -4px;
    border-radius: inherit;
    box-shadow: 0 0 16px rgba(200, 151, 62, 0.25), 0 0 6px rgba(200, 151, 62, 0.15);
    opacity: 0;
    animation: story-glow 3s ease-in-out infinite;
    pointer-events: none;
    will-change: opacity;
  }
  .story-btn:hover::before {
    opacity: 1;
    animation: none;
    box-shadow: 0 0 22px rgba(200, 151, 62, 0.2), 0 0 8px rgba(200, 151, 62, 0.1);
    transition: opacity 0.3s ease;
  }
  @keyframes story-glow {
    0%, 100% { opacity: 0; }
    50% { opacity: 1; }
  }

  #hero-hint { transition: opacity 0.8s ease; }
  #mobile-hint { transition: opacity 0.8s ease; }

  /* ===== Non-desktop: centered layout, height-adaptive block count ===== */
  @media (max-width: 1279px) {
    #spotlight-overlay {
      -webkit-mask-image:
        radial-gradient(circle 250px at var(--mx, 110%) var(--my, 110%),
          transparent 0%, rgba(0,0,0,0.3) 25%, rgba(0,0,0,0.8) 45%, black 70%),
        radial-gradient(circle 250px at var(--sx, -200%) var(--sy, -200%),
          transparent 0%, rgba(0,0,0,0.3) 25%, rgba(0,0,0,0.8) 45%, black 70%);
      mask-image:
        radial-gradient(circle 250px at var(--mx, 110%) var(--my, 110%),
          transparent 0%, rgba(0,0,0,0.3) 25%, rgba(0,0,0,0.8) 45%, black 70%),
        radial-gradient(circle 250px at var(--sx, -200%) var(--sy, -200%),
          transparent 0%, rgba(0,0,0,0.3) 25%, rgba(0,0,0,0.8) 45%, black 70%);
    }
    .code-block {
      font-size: clamp(11px, 2.5vw, 13px);
      line-height: 1.6;
      color: rgb(255, 215, 110);
      text-shadow: 0 0 8px rgba(255, 200, 80, 0.3);
      white-space: normal;
      max-width: none;
      width: 80%;
      left: 50% !important;
      right: auto !important;
      transform: translateX(-50%);
      text-align: center;
    }
    /* Base: always hide 2, 4, 6 on non-desktop */
    .code-block-2, .code-block-4, .code-block-6 { display: none !important; }
    /* Position the 3 potential blocks */
    .code-block-1 { top: max(68px, 10%) !important; }
    .code-block-3 { top: 24% !important; }
    .code-block-5 {
      top: auto !important;
      bottom: max(93px, 14.3%);
      text-shadow: 0 0 12px rgba(255, 200, 80, 0.5), 0 0 30px rgba(200, 151, 62, 0.3);
    }
  }

  /* Very short screens (small phones): only top block */
  @media (max-width: 1279px) and (max-height: 549px) {
    .code-block-3, .code-block-5 { display: none !important; }
  }

  /* Short screens (phones like iPhone SE, Galaxy S8+): top + bottom */
  @media (max-width: 1279px) and (min-height: 550px) and (max-height: 799px) {
    .code-block-3 { display: none !important; }
  }

  /* Narrow but tall screens (Z Fold, tall phones): still only 2 blocks */
  @media (max-width: 479px) and (min-height: 800px) {
    .code-block-3 { display: none !important; }
  }

  /* Wide + tall screens (480px+ wide, 800px+ tall, tablets): all 3 blocks */

  /* Mobile perf: reduce star animations from 36 to 18 */
  @media (max-width: 768px) {
    .star:nth-child(2n) { display: none; }
  }
</style>

<script>
  // Shared spotlight suppression — blocks ALL spotlight events when star button is tapped
  let __spotlightSuppressed = false;
  (function () {
    const btn = document.getElementById('story-guide-btn');
    if (!btn) return;
    // Capture on document fires before ANY other handler in the entire page
    document.addEventListener('pointerdown', (e) => {
      if (btn === e.target || btn.contains(e.target as Node)) {
        __spotlightSuppressed = true;
        setTimeout(() => { __spotlightSuppressed = false; }, 600);
      }
    }, { capture: true });
    document.addEventListener('touchstart', (e) => {
      if (btn === e.target || btn.contains(e.target as Node)) {
        __spotlightSuppressed = true;
        setTimeout(() => { __spotlightSuppressed = false; }, 600);
      }
    }, { capture: true });
  })();

  // ---- Spotlight: shared cached rect (zero layout queries per interaction) ----
  (function () {
    const hero = document.getElementById('hero');
    const overlay = document.getElementById('spotlight-overlay');
    const hint = document.getElementById('hero-hint');
    if (!hero || !overlay) return;

    // Cache hero rect — recalc on resize and interaction start (not per-frame)
    let heroLeft = 0, heroTop = 0, heroW = 0, heroH = 0;
    function cacheHeroRect() {
      const r = hero.getBoundingClientRect();
      heroLeft = r.left; heroTop = r.top; heroW = r.width; heroH = r.height;
    }
    cacheHeroRect();
    window.addEventListener('resize', cacheHeroRect, { passive: true });
    hero.addEventListener('mouseenter', cacheHeroRect, { passive: true });
    hero.addEventListener('touchstart', cacheHeroRect, { passive: true });

    let hintHidden = false;
    let spotX = '-200%';
    let spotY = '-200%';
    let spotRaf = false;

    function flushSpot() {
      if (__spotlightSuppressed) { spotRaf = false; return; }
      overlay.style.setProperty('--mx', spotX);
      overlay.style.setProperty('--my', spotY);
      spotRaf = false;
    }

    hero.addEventListener('mousemove', (e: MouseEvent) => {
      if (__spotlightSuppressed) return;
      const x = e.clientX - heroLeft;
      const y = e.clientY - heroTop;
      spotX = x + 'px';
      spotY = y + 'px';
      if (!spotRaf) { spotRaf = true; requestAnimationFrame(flushSpot); }

      if (!hintHidden && hint) {
        if (x / heroW < 0.25 && y / heroH < 0.35) {
          hint.style.opacity = '0';
          hintHidden = true;
        }
      }
    });

    hero.addEventListener('mouseleave', () => {
      spotX = '-200%'; spotY = '-200%';
      if (!spotRaf) { spotRaf = true; requestAnimationFrame(flushSpot); }
    });

    document.addEventListener('mouseleave', () => {
      spotX = '-200%'; spotY = '-200%';
      if (!spotRaf) { spotRaf = true; requestAnimationFrame(flushSpot); }
    });

    // ---- Mobile: touch to reveal (rAF-throttled, uses cached rect) ----
    let touchX = '110%';
    let touchY = '110%';
    let touchRaf = false;

    function flushTouch() {
      if (__spotlightSuppressed) { touchRaf = false; return; }
      overlay.style.setProperty('--mx', touchX);
      overlay.style.setProperty('--my', touchY);
      touchRaf = false;
    }

    function scheduleTouch() {
      if (!touchRaf) { touchRaf = true; requestAnimationFrame(flushTouch); }
    }

    hero.addEventListener('touchstart', (e: TouchEvent) => {
      if (__spotlightSuppressed) return;
      touchX = (e.touches[0].clientX - heroLeft) + 'px';
      touchY = (e.touches[0].clientY - heroTop) + 'px';
      scheduleTouch();
    }, { passive: true });

    hero.addEventListener('touchmove', (e: TouchEvent) => {
      if (__spotlightSuppressed) return;
      touchX = (e.touches[0].clientX - heroLeft) + 'px';
      touchY = (e.touches[0].clientY - heroTop) + 'px';
      scheduleTouch();
    }, { passive: true });

    hero.addEventListener('touchend', () => {
      if (__spotlightSuppressed) return;
      touchX = '110%';
      touchY = '110%';
      scheduleTouch();
    });
  })();  // end spotlight + touch IIFE

  // ---- Particle System (pauses when off-screen, optimized) ----
  (function () {
    const canvas = document.getElementById('particles') as HTMLCanvasElement;
    if (!canvas) return;
    const ctx = canvas.getContext('2d', { alpha: true });
    if (!ctx) return;
    const hero = document.getElementById('hero');
    if (!hero) return;

    let width: number, height: number;
    const isMobile = window.innerWidth < 768;
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const COUNT = prefersReducedMotion || isMobile ? 0 : 50;
    if (COUNT === 0) { canvas.style.display = 'none'; return; }
    const DIST = isMobile ? 70 : 120;
    const DIST_SQ = DIST * DIST;
    const MOUSE_DIST = DIST * 1.5;
    const MOUSE_DIST_SQ = MOUSE_DIST * MOUSE_DIST;
    const mouse = { x: -999, y: -999 };
    let animId: number;
    let isVisible = true;
    const TAU = Math.PI * 2;

    interface Particle { x: number; y: number; vx: number; vy: number; r: number; }
    let particles: Particle[] = [];

    function resize() {
      width = canvas.width = hero.offsetWidth;
      height = canvas.height = hero.offsetHeight;
    }

    function init() {
      particles = [];
      for (let i = 0; i < COUNT; i++) {
        particles.push({
          x: Math.random() * width,
          y: Math.random() * height,
          vx: (Math.random() - 0.5) * 0.3,
          vy: (Math.random() - 0.5) * 0.3,
          r: Math.random() * 1.5 + 0.5,
        });
      }
    }

    // Opacity buckets for batched line drawing (avoids per-line strokeStyle change)
    const BUCKETS = 5;
    const BUCKET_STEP = DIST_SQ / BUCKETS;
    const bucketPaths: { ax: number; ay: number; bx: number; by: number }[][] = [];
    const bucketColors: string[] = [];
    for (let b = 0; b < BUCKETS; b++) {
      bucketPaths.push([]);
      // Closer = higher opacity; bucket 0 is closest
      bucketColors.push(`rgba(200,151,62,${(0.06 * (BUCKETS - b) / BUCKETS).toFixed(4)})`);
    }

    function draw() {
      if (!isVisible) return;
      ctx.clearRect(0, 0, width, height);

      // Update positions + batch particle dots
      ctx.beginPath();
      ctx.fillStyle = 'rgba(200, 151, 62, 0.15)';
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        if (p.x < 0) p.x = width;
        if (p.x > width) p.x = 0;
        if (p.y < 0) p.y = height;
        if (p.y > height) p.y = 0;

        ctx.moveTo(p.x + p.r, p.y);
        ctx.arc(p.x, p.y, p.r, 0, TAU);
      }
      ctx.fill();

      // Clear buckets
      for (let b = 0; b < BUCKETS; b++) bucketPaths[b].length = 0;

      // Sort connections into opacity buckets (no sqrt needed)
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        for (let j = i + 1; j < particles.length; j++) {
          const q = particles[j];
          const dx = p.x - q.x;
          const dy = p.y - q.y;
          const dSq = dx * dx + dy * dy;
          if (dSq < DIST_SQ) {
            const b = (dSq / BUCKET_STEP) | 0;
            bucketPaths[b < BUCKETS ? b : BUCKETS - 1].push(
              { ax: p.x, ay: p.y, bx: q.x, by: q.y }
            );
          }
        }
      }

      // Draw each bucket with a single stroke call
      ctx.lineWidth = 0.5;
      for (let b = 0; b < BUCKETS; b++) {
        const segs = bucketPaths[b];
        if (!segs.length) continue;
        ctx.beginPath();
        ctx.strokeStyle = bucketColors[b];
        for (let s = 0; s < segs.length; s++) {
          ctx.moveTo(segs[s].ax, segs[s].ay);
          ctx.lineTo(segs[s].bx, segs[s].by);
        }
        ctx.stroke();
      }

      // Mouse lines — single batch
      if (mouse.x > -900) {
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(200,151,62,0.12)';
        ctx.lineWidth = 0.6;
        for (let i = 0; i < particles.length; i++) {
          const p = particles[i];
          const mdx = p.x - mouse.x;
          const mdy = p.y - mouse.y;
          if (mdx * mdx + mdy * mdy < MOUSE_DIST_SQ) {
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(mouse.x, mouse.y);
          }
        }
        ctx.stroke();
      }

      animId = requestAnimationFrame(draw);
    }

    const observer = new IntersectionObserver(
      ([entry]) => {
        isVisible = entry.isIntersecting;
        if (isVisible) animId = requestAnimationFrame(draw);
        else cancelAnimationFrame(animId);
      },
      { threshold: 0 }
    );
    observer.observe(hero);

    // Only track mouse on desktop — disable particle touch interaction on mobile
    if (!isMobile) {
      hero.addEventListener('mousemove', (e: MouseEvent) => {
        const r = hero.getBoundingClientRect();
        mouse.x = e.clientX - r.left;
        mouse.y = e.clientY - r.top;
      });
      hero.addEventListener('mouseleave', () => { mouse.x = mouse.y = -999; });
    }
    window.addEventListener('resize', resize);

    resize();
    init();
    draw();
  })();

  // ---- Typing Effect with rotating roles ----
  (function () {
    const el = document.getElementById('typed-text');
    const subtitle = document.getElementById('hero-subtitle');
    const cta = document.getElementById('hero-cta');
    const roleEl = document.getElementById('hero-role');
    if (!el) return;

    const names = {
      en: 'Krasimir Kralev',
      bg: 'Красимир Кралев',
    };

    const roles = {
      en: ['Web Developer', 'QA Specialist', 'Guitarist @ Slathe', 'Web3 Enthusiast'],
      bg: ['Уеб Разработчик', 'QA Специалист', 'Китарист @ Slathe', 'Web3 Ентусиаст'],
    };
    let roleIdx = 0;

    function getLang(): string {
      return document.documentElement.dataset.lang || 'en';
    }

    const lang = getLang() as keyof typeof names;
    const text = names[lang] || names.en;
    let i = 0;

    function cycleRole() {
      if (!roleEl) return;
      const lang = getLang() as keyof typeof roles;
      const list = roles[lang] || roles.en;
      roleEl.style.opacity = '0';
      setTimeout(() => {
        roleIdx = (roleIdx + 1) % list.length;
        roleEl.textContent = list[roleIdx];
        roleEl.style.opacity = '1';
      }, 400);
    }

    const cursor = document.getElementById('typed-cursor');

    function finishTyping() {
      const lang = getLang() as keyof typeof roles;
      const list = roles[lang] || roles.en;
      if (roleEl) {
        roleEl.textContent = list[0];
        roleEl.style.transition = 'opacity 0.4s ease';
      }
      subtitle?.classList.remove('opacity-0', 'translate-y-2');
      subtitle?.classList.add('opacity-100', 'translate-y-0');
      cta?.classList.remove('opacity-0', 'translate-y-2');
      cta?.classList.add('opacity-100', 'translate-y-0');
      // Fade out cursor after typing
      if (cursor) {
        cursor.style.transition = 'opacity 0.5s ease';
        cursor.style.opacity = '0';
        setTimeout(() => { cursor.style.display = 'none'; }, 500);
      }
      setInterval(cycleRole, 3000);
    }

    // If name was already typed (e.g. navigated back), show it instantly
    if (el.textContent && el.textContent.length > 0) {
      finishTyping();
    } else {
      function typeChar() {
        if (i < text.length) {
          el.textContent += text.charAt(i);
          i++;
          setTimeout(typeChar, 65);
        } else {
          finishTyping();
        }
      }
      setTimeout(typeChar, 600);
    }

    // Swap name when language changes
    new MutationObserver(() => {
      const newLang = getLang() as keyof typeof names;
      el.textContent = names[newLang] || names.en;
      if (roleEl) {
        const list = roles[newLang] || roles.en;
        roleEl.textContent = list[roleIdx % list.length];
      }
    }).observe(document.documentElement, { attributes: true, attributeFilter: ['data-lang'] });
  })();

  // ---- Star trail guide animation ----
  (function () {
    const btn = document.getElementById('story-guide-btn');
    const hero = document.getElementById('hero');
    const svg = document.getElementById('star-trail') as SVGSVGElement | null;
    const trailPath = document.getElementById('trail-path') as SVGPathElement | null;
    const trailStar = document.getElementById('trail-star') as SVGCircleElement | null;
    const sparklesG = document.getElementById('trail-sparkles');
    if (!btn || !hero || !svg || !trailPath || !trailStar || !sparklesG) return;

    const overlay = document.getElementById('spotlight-overlay');
    let running = false;

    // Sparkle pool: reuse DOM nodes instead of create/remove
    const SPARKLE_POOL_SIZE = 35;
    const SPARKLE_LIFE = 700;
    const sparklePool: SVGCircleElement[] = [];
    const activeSparkles: { el: SVGCircleElement; born: number }[] = [];

    for (let i = 0; i < SPARKLE_POOL_SIZE; i++) {
      const c = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      c.setAttribute('r', '2');
      c.setAttribute('fill', '#ffd97a');
      c.setAttribute('opacity', '0');
      sparklesG!.appendChild(c);
      sparklePool.push(c);
    }
    let poolIdx = 0;

    function clearSparkles() {
      for (let i = 0; i < SPARKLE_POOL_SIZE; i++) {
        sparklePool[i].setAttribute('opacity', '0');
      }
      activeSparkles.length = 0;
    }

    // Batch-fade all sparkles in one pass (no individual rAF loops)
    function fadeSparkles(now: number) {
      for (let i = activeSparkles.length - 1; i >= 0; i--) {
        const s = activeSparkles[i];
        const age = now - s.born;
        const o = Math.max(0, 1 - age / SPARKLE_LIFE);
        if (o <= 0) {
          s.el.setAttribute('opacity', '0');
          activeSparkles.splice(i, 1);
        } else {
          s.el.setAttribute('opacity', `${(o * 0.9).toFixed(2)}`);
        }
      }
    }

    btn.addEventListener('click', () => {
      if (running) return;
      running = true;

      const heroRect = hero.getBoundingClientRect();
      const btnRect = btn.getBoundingClientRect();

      // Start: center of button (relative to hero)
      const sx = btnRect.left - heroRect.left + btnRect.width / 2;
      const sy = btnRect.top - heroRect.top + btnRect.height / 2;

      // End: hint beacon area (top-left corner)
      const ex = heroRect.width * 0.06;
      const ey = heroRect.height * 0.15;

      // Curved path via control points
      const cp1x = sx - (sx - ex) * 0.3;
      const cp1y = sy - (sy - ey) * 0.7;
      const cp2x = ex + (sx - ex) * 0.1;
      const cp2y = ey + (sy - ey) * 0.15;

      const d = `M ${sx} ${sy} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${ex} ${ey}`;
      trailPath.setAttribute('d', d);

      const pathLen = trailPath.getTotalLength();
      trailPath.style.strokeDasharray = `${pathLen}`;
      trailPath.style.strokeDashoffset = `${pathLen}`;

      svg.style.display = '';
      trailPath.style.opacity = '0.8';
      trailStar.style.opacity = '1';
      clearSparkles();

      // Initialize star spotlight position on the overlay
      if (overlay) {
        overlay.style.setProperty('--sx', '-200%');
        overlay.style.setProperty('--sy', '-200%');
      }

      const duration = 1000;
      const start = performance.now();
      let lastSparkle = 0;

      function animate(now: number) {
        const elapsed = now - start;
        const t = Math.min(elapsed / duration, 1);
        // Ease out cubic — smooth deceleration
        const ease = 1 - Math.pow(1 - t, 3);

        // Draw trail
        trailPath!.style.strokeDashoffset = `${pathLen * (1 - ease)}`;

        // Move star along path
        const pt = trailPath!.getPointAtLength(pathLen * ease);
        trailStar!.setAttribute('cx', `${pt.x}`);
        trailStar!.setAttribute('cy', `${pt.y}`);

        // Star spotlight follows the star — only activate after star is well past the button
        if (overlay && ease > 0.5) {
          overlay.style.setProperty('--sx', `${pt.x}px`);
          overlay.style.setProperty('--sy', `${pt.y}px`);
        }

        // Smooth grow: 5 → 9px radius with ease
        const starR = 5 + ease * 4;
        trailStar!.setAttribute('r', `${starR.toFixed(1)}`);

        // Spawn sparkles every ~35ms — reuse pooled elements
        if (elapsed - lastSparkle > 35 && t < 0.92) {
          lastSparkle = elapsed;
          const spark = sparklePool[poolIdx % SPARKLE_POOL_SIZE];
          poolIdx++;
          spark.setAttribute('cx', `${pt.x + (Math.random() - 0.5) * 14}`);
          spark.setAttribute('cy', `${pt.y + (Math.random() - 0.5) * 14}`);
          spark.setAttribute('r', `${(1.5 + Math.random() * 2.5).toFixed(1)}`);
          spark.setAttribute('fill', Math.random() > 0.3 ? '#ffd97a' : '#fff');
          spark.setAttribute('opacity', '0.9');
          activeSparkles.push({ el: spark, born: now });
        }

        // Batch-fade all active sparkles in one pass
        fadeSparkles(now);

        if (t < 1) {
          requestAnimationFrame(animate);
        } else {
          // Smooth ending: grow + fade simultaneously via rAF
          const fadeStart = performance.now();
          const fadeDuration = 500;
          const endR = starR;

          function fadeOut(now: number) {
            const ft = Math.min((now - fadeStart) / fadeDuration, 1);
            const fEase = 1 - Math.pow(1 - ft, 2); // ease out quad

            // Grow star smoothly: 9 → 12
            trailStar!.setAttribute('r', `${(endR + fEase * 3).toFixed(1)}`);
            // Fade trail + star
            trailPath!.style.opacity = `${(0.8 * (1 - fEase)).toFixed(2)}`;
            trailStar!.style.opacity = `${(1 - fEase).toFixed(2)}`;
            // Fade sparkles too
            fadeSparkles(now);

            if (ft < 1) {
              requestAnimationFrame(fadeOut);
            } else {
              // Move star spotlight off-screen
              if (overlay) {
                overlay.style.setProperty('--sx', '-200%');
                overlay.style.setProperty('--sy', '-200%');
              }
              setTimeout(() => {
                svg!.style.display = 'none';
                trailStar!.setAttribute('r', '5');
                trailStar!.style.opacity = '1';
                trailPath!.style.opacity = '0.8';
                clearSparkles();
                running = false;
              }, 300);
            }
          }
          requestAnimationFrame(fadeOut);
        }
      }

      requestAnimationFrame(animate);
    });
  })();

  // ---- Dynamic spacing for stacked code blocks on non-desktop ----
  (function () {
    if (window.innerWidth >= 1280) return;

    const hero = document.getElementById('hero');
    if (!hero) return;
    const GAP = 18;
    const lang = () => document.documentElement.dataset.lang || 'en';

    function reflow() {
      if (window.innerWidth >= 1280) return;
      const b1 = hero.querySelector(`.code-block-1[data-lang="${lang()}"]`) as HTMLElement;
      const b3 = hero.querySelector(`.code-block-3[data-lang="${lang()}"]`) as HTMLElement;
      if (!b1 || !b3 || getComputedStyle(b3).display === 'none') return;

      const heroRect = hero.getBoundingClientRect();
      const b1Rect = b1.getBoundingClientRect();
      const newTop = b1Rect.bottom - heroRect.top + GAP;
      b3.style.top = newTop + 'px';
    }

    // Run after fonts load and on resize
    reflow();
    document.fonts?.ready.then(reflow);
    window.addEventListener('resize', reflow);
    // Re-run on language change
    new MutationObserver(reflow).observe(document.documentElement, { attributes: true, attributeFilter: ['data-lang'] });
  })();
</script>
